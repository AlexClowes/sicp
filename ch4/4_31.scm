; Apply
(define (apply procedure arguments env)
  (cond ((primitive-procedure? procedure)
         (apply-primitive-procedure procedure 
                                    (list-of-arg-values arguments env)))
        ((compound-procedure? procedure)
         (eval-sequence (procedure-body procedure)
                        (extend-environment (procedure-parameter-names procedure)
                                            (compound-procedure-args procedure
                                                                     arguments
                                                                     env)
                                            (procedure-environment procedure))))
        (else (error "Unknown procedure type -- APPLY" procedure))))

; Procedure arguments
(define (list-of-arg-values exps env)
  (map (lambda (exp) (actual-value exp env))
       exps))
(define (compound-procedure-args procedure exps env)
  (define (convert-exp param exp)
    (cond ((eager? param) (eval exp env))
          ((lazy? param) (delay-it exp env))
          ((lazy-memo? param) (delay-it-memoized exp env))
          (else (error "Unknown parameter type -- COMPOUND-PROCEDURE-ARGS" param))))
  (map convert-exp
       (procedure-parameters procedure)
       exps))

; Representing procedures
(define (make-procedure paramters body env)
  (list 'procedure paramters body env))
(define (compound-procedure? p)
  (tagged-list? p 'procedure))
(define (procedure-parameters p) (cadr p))
(define (procedure-parameter-names p)
  (map (lambda (x) (if (pair? x) (car x) x))
       (procedure-parameters p)))
(define (procedure-body p) (caddr p))
(define (procedure-environment p) (cadddr p))

; Thunks
(define (actual-value exp env)
  (force-it (eval exp env)))
(define (force-it obj)
  (cond ((thunk? obj)
         (actual-value (thunk-exp obj) (thunk-env obj)))
        ((memoized-thunk? obj)
         (let ((result (actual-value (thunk-exp obj) (thunk-env obj))))
           (set-car! obj 'evaluated-thunk)
           (set-car! (cdr obj) result)
           (set-cdr! (cdr obj) '())
           result))
        ((evaluated-thunk? obj) (thunk-value obj))
        (else obj)))
(define (delay-it exp env)
  (list 'thunk exp env))
(define (delay-it-memoized exp env)
  (list 'memoized-thunk exp env))
(define (thunk? obj)
  (tagged-list? obj 'thunk))
(define (memoized-thunk? obj)
  (tagged-list? obj 'memoized-thunk))
(define (thunk-exp obj) (cadr obj))
(define (thunk-env obj) (caddr thunk))
(define (evaluated-thunk? obj)
  (tagged-list? 'evaluated-thunk))
(define (thunk-value evaluated-thunk) (cadr evaluated-thunk))

; Parameter types
(define (eager? param)
  (not (pair? param)))
(define (lazy? param)
  (and (pair? param) (eq? (cdr param) 'lazy)))
(define (lazy-memo? param)
  (and (pair? param) (eq? (cdr param) 'lazy-memo)))
